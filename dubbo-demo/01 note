一、概述
1、git 从tag分支拉取标签
2、dubbo 解决分布式事务


二、Spring 专题
1、RootBeanDefinition 使用原理 用于spring对象创建
2、DubboBeanDefinitionParser#parse 获取class属性的意义
3、为何两者都能使用：
    （1）RuntimeBeanReference 解析阶段依赖其他对象的实例，但是实例还没创建完毕
    （2）BeanDefinitionHolder 作用？
4、对象实现执行顺序专题：FactoryBean, ApplicationContextAware, InitializingBean, DisposableBean
    (1) FactoryBean：FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。
    (2) ApplicationContextAware：
    (3) InitializingBean, DisposableBean 类的初始化和销毁
    同一个Bean中：先构造函数 --> 然后是set方法注入 --> ApplicationContextAware#setApplicationContext()
        --> InitializingBean的afterPropertiesSet方法 --> init-method方法

    ReferenceBean->Constructor              invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->setApplicationContext    invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->afterPropertiesSet       invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->isSingleton              invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->getObjectType            invoke...interface com.alibaba.dubbo.demo.DemoService2, dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->isSingleton              invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->getObjectType            invoke...interface com.alibaba.dubbo.demo.DemoService2, dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->isSingleton              invoke..., dubbo version: 2.0.0, current host: 192.168.99.138
    ReferenceBean->getObject                invoke..., dubbo version: 2.0.0, current host: 192.168.99.138

5、ClassPathXmlApplicationContext
    您可以创建一个实现的类的bean继承ApplicationListener<ContextStartedEvent>
    当您调用时start()，ApplicationContext将发布此类事件，并且所有ApplicationListener注册的bean ContextStartedEvent（如果在上下文中找到它们将自动注册）将收到通知。

三、Java基础
1、系统变量之System.getenv()和System.getProperty()
    （1）System.getenv() 获取环境变量
    （2）System.getProperty() 是获取系统的相关属性，包括文件编码、操作系统名称、区域、用户名等，此属性一般由jvm自动获取，不能设置。
2、

四、SPI为什么复杂设计？
为什么不设计跟jdk的spi类似？

五、Zookeeper
1、zk的状态
（1）org.apache.zookeeper.Watcher.Event.EventType 五种事件类型（节点相关）
（2）org.apache.zookeeper.Watcher.Event.KeeperState 六种状态（客户端连接相关）
2、注册监听的三种类型
（1）对父节点添加监听子节点变化：
    - parentPath 为监听节点全路径
    - currentChilds为新的子节点列表
    IZKChildListener事件说明针对于下面四个事件触发：
    - 新增子节点
    - 减少子节点
    - 删除节点
    - 新创建节点
    注意： 不监听节点内容的变化
    [Demo:]
    zkc.subscribeChildChanges("/super", new IZkChildListener() {
        @Override
        public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {
            System.out.println("subscribeChildChanges -> parentPath: " + parentPath);
            System.out.println("subscribeChildChanges -> currentChilds: " + currentChilds);
        }
    });

（2）对父节点添加监听节点内容变化：节点内容变化、节点删除、节点创建
    [Demo:]
    zkc.subscribeDataChanges("/super", new IZkDataListener() {
        @Override
        public void handleDataDeleted(String path) throws Exception {
            System.out.println("subscribeDataChanges -> handleDataDeleted 删除的节点为:" + path);
        }

        @Override
        public void handleDataChange(String path, Object data) throws Exception {
            System.out.println("subscribeDataChanges -> handleDataChange 变更的节点为:" + path + ", 变更内容为:" + data);
        }
    });
（3）监听服务状态：
    当我只连接zk服务集群中单独的一个zk服务时：
    ./zkServer.sh stop 连接断开
    ./zkServer.sh start 连接成功
    ./zkServer.sh restart 连接断开 连接成功
    ./zkServer.sh stop 连接断开
    等待几分钟
    ./zkServer.sh start 其他状态Expired ---->重建session 连接成功
    [Demo:]
    zkc.subscribeStateChanges(new IZkStateListener() {
        @Override
        public void handleStateChanged(Watcher.Event.KeeperState state) throws Exception {
            if (state == Watcher.Event.KeeperState.SyncConnected) {
                System.out.println("subscribeStateChanges -> KeeperState.SyncConnected 连接成功"); // 当我重新启动后start，监听触发
            } else if (state == Watcher.Event.KeeperState.Disconnected) {
                System.out.println("subscribeStateChanges -> KeeperState.Disconnected 连接断开"); // 当我在服务端将zk服务stop时，监听触发
            } else
                System.out.println("subscribeStateChanges -> 其他状态" + state);
        }

        @Override
        public void handleNewSession() {
            System.out.println("subscribeStateChanges -> handleNewSession 重建session");
        }
    });
